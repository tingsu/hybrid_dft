type terminal = { text : string }
type nonterminal = { name : string }

type either = Term of terminal | Nonterm of nonterminal
type production = either list

module SetOfProductions = Set.Make(struct type t = production let compare = compare end)
type productions = SetOfProductions.t

module NontermMap = Map.Make(struct type t = nonterminal let compare = compare end)
module N = NontermMap
type grammar = productions NontermMap.t
let empty_grammar = NontermMap.empty

let add_productions nonterm productions grammar =
    let old_prods = try N.find nonterm grammar with Not_found -> SetOfProductions.empty in
    N.add nonterm (SetOfProductions.union productions old_prods) grammar

let merge_grammars grammar1 grammar2 =
    N.fold add_productions grammar1 grammar2

(** The next few functions each return a nonterminal producing some
    variant of the given production. This nonterminal is generated if
    necessary. These function also return a grammar which, if the
    nonterminal was generated by this call to the function, maps the
    nonterminal to the new production. Otherwise, the grammar returned is
    empty. *)

(** [get_optional production] returns a nonterminal optionally
    producing [production]. That is, the resulting nonterminal N is
    defined as N ::= "" | production. *)
let get_optional =
    (** Hashtable memoizing production we've already created options for *)
    let table : (production, nonterminal) Hashtbl.t = Hashtbl.create 13 in
    let next_nonterm =
        let counter = ref (-1) in
        (fun () -> incr counter; { name = "optional_" ^ string_of_int !counter })
    in
    fun production ->
        try
            let nonterm = Hashtbl.find table production in
            (Nonterm nonterm, empty_grammar)
        with Not_found ->
            let new_nonterm = next_nonterm () in
            Hashtbl.add table production new_nonterm;
            let option = SetOfProductions.singleton [Term { text = "" }] in
            let option = SetOfProductions.add production option in
            let grammar = N.singleton new_nonterm option in
            (Nonterm new_nonterm, grammar)

(** [get_star production] returns a nonterminal the Kleene star of
    [production]. That is, the resulting nonterminal N is defined as N ::= "" |
    production N. *)
let get_star =
    (** Hashtable memoizing production we've already created stars for *)
    let table : (production, nonterminal) Hashtbl.t = Hashtbl.create 13 in
    let next_nonterm =
        let counter = ref (-1) in
        (fun () -> incr counter; { name = "star_" ^ string_of_int !counter })
    in
    fun production ->
        try
            let nonterm = Hashtbl.find table production in
            (Nonterm nonterm, empty_grammar)
        with Not_found ->
            let new_nonterm = next_nonterm () in
            Hashtbl.add table production new_nonterm;
            let star = SetOfProductions.singleton [Term { text = "" }] in
            let star = SetOfProductions.add (production @ [Nonterm new_nonterm]) star in
            let grammar = N.singleton new_nonterm star in
            (Nonterm new_nonterm, grammar)

(** [get_plus production] returns a nonterminal producing any positive number of
    repetitions of [production]. That is, the resulting nonterminal N is defined
    as N ::= production production*. *)
let get_plus =
    (** Hashtable memoizing production we've already created pluses for *)
    let table : (production, nonterminal) Hashtbl.t = Hashtbl.create 13 in
    let next_nonterm =
        let counter = ref (-1) in
        (fun () -> incr counter; { name = "plus_" ^ string_of_int !counter })
    in
    fun production ->
        try
            let nonterm = Hashtbl.find table production in
            (Nonterm nonterm, empty_grammar)
        with Not_found ->
            let new_nonterm = next_nonterm () in
            Hashtbl.add table production new_nonterm;
            let star_nonterm, grammar = get_star production in
            let plus = SetOfProductions.singleton (production @ [star_nonterm]) in
            let grammar = N.add new_nonterm plus grammar in
            (Nonterm new_nonterm, grammar)


(** [get_auxiliary productions] returns a nonterminal producing the given
    [productions]. *)
let get_auxiliary =
    (** Hashtable memoizing productions we've already created auxiliary variables for *)
    let table : (productions, nonterminal) Hashtbl.t = Hashtbl.create 13 in
    let next_nonterm =
        let counter = ref (-1) in
        (fun () -> incr counter; { name = "auxiliary_" ^ string_of_int !counter })
    in
    fun productions ->
        try
            let nonterm = Hashtbl.find table productions in
            (Nonterm nonterm, empty_grammar)
        with Not_found ->
            let new_nonterm = next_nonterm () in
            Hashtbl.add table productions new_nonterm;
            let grammar = N.singleton new_nonterm productions in
            (Nonterm new_nonterm, grammar)

let reserved_prefix_list = [ "optional_"; "star_"; "plus_"; "auxiliary_" ]
let reserved_prefix string =
    let rec check_remaining = function
          [] -> None
        | prefix::prefixes ->
            if Str.string_match (Str.regexp prefix) string 0
            then Some prefix
            else check_remaining prefixes
    in
    check_remaining reserved_prefix_list
